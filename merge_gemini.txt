Funcao ordenar_blocos(n_linhas_arquivo, P, M) // Adicionei P e M como parâmetros explícitos
  // n_linhas_arquivo: número total de linhas do arquivo original
  // P: número de arquivos/blocos ordenados a serem intercalados simultaneamente
  // M: tamanho inicial dos blocos ordenados

  // Conjuntos de arquivos (pense neles como grupos de índices de dispositivos)
  // Assumimos que os primeiros P dispositivos (0 a P-1) são de destino e os próximos P (P a 2P-1) são de fonte
  Conjunto_Arquivos_Fonte = "dispositivos de P até 2P-1"
  Conjunto_Arquivos_Destino = "dispositivos de 0 até P-1"

  tamanho_bloco_ordenado_atual = M // Começa com o tamanho dos blocos ordenados iniciais

  while(tamanho_bloco_ordenado_atual < n_linhas_arquivo) // Continua enquanto não tivermos um único bloco ordenado final
    limpar_arquivos_destino(Conjunto_Arquivos_Destino) // Garante que os arquivos de destino estão vazios

    indice_arquivo_destino_atual = 0 // Índice para distribuir os novos blocos ordenados gerados no Conjunto_Arquivos_Destino

    // Calcula o número total de blocos ordenados de 'tamanho_bloco_ordenado_atual' existentes para processar
    num_blocos_ordenados_totais_nesta_passagem = CEIL(n_linhas_arquivo / tamanho_bloco_ordenado_atual) // Use CEIL para pegar o teto

    // Iterando sobre os grupos de P blocos ordenados a serem intercalados em um único passo
    for (int i=0; i < num_blocos_ordenados_totais_nesta_passagem / P + (num_blocos_ordenados_totais_nesta_passagem % P != 0 ? 1 : 0); i++) { // Garante que todos os grupos são processados, incluindo o último incompleto
                                                                                                                // Alternativa mais simples: for (int i=0; i<CEIL(num_blocos_ordenados_totais_nesta_passagem / (double)P); i++)
        Lista_Canais_Leitura = Nova_Lista // Lista de canais abertos para este grupo de P blocos ordenados
        Contador_Blocos_Ordenados_Abertos = 0 // Conta quantos blocos de entrada foram realmente abertos para este merge

        // *** AQUI É ONDE SE ABREM OS CANAIS E SE PREPARA PARA UM ÚNICO MERGE DE P VIAS ***
        for(int j=0; j< P; j++) // Loop para tentar abrir P canais de leitura
            indice_bloco_ordenado_global = (i * P) + j // Calcula qual bloco ordenado global estamos tentando abrir

            Se indice_bloco_ordenado_global < num_blocos_ordenados_totais_nesta_passagem: // Verifica se este bloco ordenado existe
                // Abre o canal de leitura para este bloco ordenado específico
                // Esta função precisa saber em qual arquivo ele está e a posição inicial/final dentro do arquivo
                canal_leitura = Abrir_Canal_Leitura_Para_Bloco_Ordenado(Conjunto_Arquivos_Fonte, indice_bloco_ordenado_global, tamanho_bloco_ordenado_atual)
                Adicionar(canal_leitura, Lista_Canais_Leitura)
                Contador_Blocos_Ordenados_Abertos = Contador_Blocos_Ordenados_Abertos + 1
            Senão:
                Quebrar Loop Interno // Não há mais blocos ordenados suficientes para completar P, sai do 'for j'

        Se Contador_Blocos_Ordenados_Abertos == 0:
            Quebrar Loop Externo // Não há mais blocos ordenados para processar em grupos, sai do 'for i'

        // Abre UM canal de escrita para o novo bloco ordenado que será gerado
        canal_escrita = Abrir_Canal_Escrita_Para_Arquivo(Conjunto_Arquivos_Destino, indice_arquivo_destino_atual)

        // *** AQUI COMEÇA A LÓGICA DE INTERCALAÇÃO REAL PARA ESTE GRUPO DE BLOCOS ORDENADOS ***
        // Vetor que armazenará a próxima linha de cada um dos canais de entrada
        Vetor_Proximas_Linhas = Array de tamanho P // Inicializa com capacidade P
        
        // Inicializa o vetor com a primeira linha de cada canal de leitura
        Para cada canal em Lista_Canais_Leitura:
            Se canal.TemMaisLinhas():
                linha = canal.LerProximaLinha()
                Vetor_Proximas_Linhas[canal.ID] = (linha, canal.ID) // Assume que canal.ID é um índice válido para o vetor
            Senão:
                Vetor_Proximas_Linhas[canal.ID] = VAZIO // Marca a posição como vazia

        // Loop principal da intercalação: continua enquanto houver linhas válidas para intercalar
        Enquanto EXISTE_LINHA_VALIDA_NO_VETOR(Vetor_Proximas_Linhas):
            // Encontrar a menor linha no vetor (busca linear, como planejado para P pequeno)
            menor_linha = NULO // Sentinela para a menor linha encontrada
            ID_do_menor_canal = -1

            Para cada posicao 'idx' de 0 até Vetor_Proximas_Linhas.Tamanho - 1:
                Se Vetor_Proximas_Linhas[idx] NÃO É VAZIO:
                    (linha_candidata, ID_candidato) = Vetor_Proximas_Linhas[idx]
                    Se menor_linha É NULO OU Comparar(linha_candidata, menor_linha) < 0:
                        menor_linha = linha_candidata
                        ID_do_menor_canal = ID_candidato
            
            Se menor_linha É NULO: // Se o vetor está todo VAZIO, não há mais linhas para intercalar
                Quebrar Loop // Sai do Enquanto EXISTE_LINHA_VALIDA_NO_VETOR

            Escrever(menor_linha, canal_escrita) // Escreve a menor linha no arquivo de saída

            // Lê a próxima linha DO MESMO BLOCO ORDENADO de onde a menor linha veio
            canal_origem = Encontrar_Canal_Por_ID(Lista_Canais_Leitura, ID_do_menor_canal)
            Se canal_origem.TemMaisLinhas():
                nova_linha = canal_origem.LerProximaLinha()
                Vetor_Proximas_Linhas[ID_do_menor_canal] = (nova_linha, ID_do_menor_canal)
            Senão:
                Vetor_Proximas_Linhas[ID_do_menor_canal] = VAZIO // Marca como exaurido
        // *** FIM DA LÓGICA DE INTERCALAÇÃO REAL ***

        // *** AQUI SE FECHAM OS CANAIS APÓS UM ÚNICO MERGE DE P VIAS ***
        Para cada canal em Lista_Canais_Leitura:
            canal.Fechar() // Fecha os canais de leitura dos blocos ordenados que foram consumidos
        canal_escrita.Fechar() // Fecha o canal de escrita do novo bloco ordenado gerado

        // Varia o arquivo de destino para distribuir os novos blocos ordenados
        indice_arquivo_destino_atual = (indice_arquivo_destino_atual + 1) % P // Isso garante a distribuição cíclica entre 0 e P-1

    Trocar_Conjuntos_Arquivos(Conjunto_Arquivos_Fonte, Conjunto_Arquivos_Destino) // Troca os papéis para a próxima passagem
    
    tamanho_bloco_ordenado_atual *= P; // O tamanho dos blocos ordenados cresce por um fator de P

// O arquivo final ordenado estará no conjunto que é 'Conjunto_Arquivos_Fonte' após o loop final
Retornar "O Arquivo Final Ordenado"


// Funções Auxiliares (Você precisará implementar ou adaptar):
// - limpar_arquivos_destino(Conjunto_Arquivos_Destino): Limpa os arquivos antes de cada passagem.
// - Abrir_Canal_Leitura_Para_Bloco_Ordenado(Conjunto_Arquivos_Fonte, indice_bloco_ordenado_global, tamanho_bloco_ordenado_atual):
//   Retorna um canal de leitura posicionado no início do bloco ordenado correto dentro do arquivo físico,
//   e com lógica para parar de ler quando o `tamanho_bloco_ordenado_atual` de linhas for atingido para aquele bloco.
// - Abrir_Canal_Escrita_Para_Arquivo(Conjunto_Arquivos_Destino, indice_arquivo_destino_atual):
//   Retorna um canal de escrita para o arquivo de destino apropriado.
// - Encontrar_Canal_Por_ID(Lista_Canais_Leitura, ID_do_menor_canal): Retorna o objeto canal de leitura a partir de seu ID.
// - EXISTE_LINHA_VALIDA_NO_VETOR(Vetor_Proximas_Linhas):
//   Retorna VERDADEIRO se o Vetor_Proximas_Linhas contém pelo menos uma linha que NÃO É VAZIO.
// - Comparar(linha1, linha2): Compara duas linhas com base na(s) chave(s) de ordenação.
// - Trocar_Conjuntos_Arquivos(ref Conjunto_Arquivos_Fonte, ref Conjunto_Arquivos_Destino):
//   Função que troca os conjuntos de arquivos (fonte vira destino, destino vira fonte).