#############################################################################################################
######################################### Funções Auxiliares ###############################################
#############################################################################################################

Funcao Limpar_Arquivos_Destino(Conjunto_Arquivos_Destino)
    deixa os arquivos vazios so p n dar BO

Funcao Calcular_Num_Blocos_Totais_Nesta_Passagem(n_linhas_arquivo, tamanho_bloco_ordenado_atual)
    // Calcula o número total de blocos ordenados existentes para processar nesta passagem
    Retornar CEIL(n_linhas_arquivo / tamanho_bloco_ordenado_atual)

//abre os arquivos necessario para leitura
Funcao Abrir_arquivos_Leitura_Para_Grupo(i, P, num_blocos_ordenados_totais_nesta_passagem, Conjunto_Arquivos_Fonte, tamanho_bloco_ordenado_atual)
    Lista_arquivos_Leitura = Nova_Lista // Lista para armazenar os arquivos de leitura abertos
    Contador_Blocos_Ordenados_Abertos = 0

    // Tenta abrir até P arquivos de leitura para o grupo atual de blocos ordenados
    Para j de 0 até P-1:
        indice_bloco_ordenado_global = (i * P) + j 

        Se indice_bloco_ordenado_global < num_blocos_ordenados_totais_nesta_passagem:
            arquivos_leitura = Abrir_arquivos_Leitura_Para_Bloco_Ordenado(Conjunto_Arquivos_Fonte, indice_bloco_ordenado_global, tamanho_bloco_ordenado_atual)
            Adicionar(arquivos_leitura, Lista_arquivos_Leitura)
            Contador_Blocos_Ordenados_Abertos = Contador_Blocos_Ordenados_Abertos + 1
        Senão:
            Quebrar Loop // Não há mais blocos ordenados para este grupo
    
    Retornar (Lista_arquivos_Leitura, Contador_Blocos_Ordenados_Abertos) // Retorna os canais e a contagem

Funcao Abrir_arquivos_Escrita_Para_Arquivo_Destino(Conjunto_Arquivos_Destino, indice_arquivo_destino_atual)
    // Abre UM arquivos de escrita para o arquivo de destino apropriado.
    Retornar Abrir_arquivos_Escrita_Para_Arquivo(Conjunto_Arquivos_Destino, indice_arquivo_destino_atual)

Funcao Inicializar_Vetor_Proximas_Linhas(Lista_Canais_Leitura, P)
    Vetor_Proximas_Linhas = Array de tamanho P // Inicializa o vetor
    
    // Preenche o vetor com a primeira linha de cada canal
    Para cada arquivos em Lista_Canais_Leitura:
        Se arquivos.TemMaisLinhas():
            linha = arquivos.LerProximaLinha()
            Vetor_Proximas_Linhas[arquivos.ID] = (linha, arquivos.ID)
        Senão:
            Vetor_Proximas_Linhas[arquivos.ID] = VAZIO
    Retornar Vetor_Proximas_Linhas

Funcao Realizar_Merge_De_P_Vias(Lista_Canais_Leitura, Vetor_Proximas_Linhas, arquivos_escrita)
    // Loop principal da intercalação: continua enquanto houver linhas válidas para intercalar
    Enquanto EXISTE_LINHA_VALIDA_NO_VETOR(Vetor_Proximas_Linhas):
        menor_linha = NULO
        ID_do_menor_arquivosl = -1

        // Encontrar a menor linha no vetor (busca linear)
        Para cada posicao 'idx' de 0 até Vetor_Proximas_Linhas.Tamanho - 1:
            Se Vetor_Proximas_Linhas[idx] NÃO É VAZIO:
                (linha_candidata, ID_candidato) = Vetor_Proximas_Linhas[idx]
                Se menor_linha É NULO OU Comparar(linha_candidata, menor_linha) < 0:
                    menor_linha = linha_candidata
                    ID_do_menor_arquivos = ID_candidato
        
        Se menor_linha É NULO: // Se o vetor está todo VAZIO, não há mais linhas para intercalar
            Quebrar Loop // Sai do Enquanto EXISTE_LINHA_VALIDA_NO_VETOR

        Escrever(menor_linha, arquivos_escrita)

        // Lê a próxima linha DO MESMO BLOCO ORDENADO de onde a menor linha veio
        arquivos_origem = Encontrar_arquivos_Por_ID(Lista_Canais_Leitura, ID_do_menor_arquivos)
        Se arquivos_origem.TemMaisLinhas():
            nova_linha = arquivos_origem.LerProximaLinha()
            Vetor_Proximas_Linhas[ID_do_menor_arquivos] = (nova_linha, ID_do_menor_arquivos)
        Senão:
            Vetor_Proximas_Linhas[ID_do_menor_arquivos] = VAZIO // Marca como exaurido

Funcao Fechar_arquivos_Merge(Lista_arquivos_Leitura, arquivos_escrita)
    Para cada arquivos em Lista_arquivos_Leitura:
        arquivos.Fechar()
    arquivos_escrita.Fechar()

Funcao Atualizar_Indice_Destino(indice_atual, P)
    Retornar (indice_atual + 1) % P

Funcao Trocar_Conjuntos_Arquivos(ref Conjunto_Arquivos_Fonte, ref Conjunto_Arquivos_Destino)
    // Lógica para trocar os conjuntos, como você já tinha
    int aux_ref_fonte = Conjunto_Arquivos_Fonte
    Conjunto_Arquivos_Fonte = Conjunto_Arquivos_Destino
    Conjunto_Arquivos_Destino = aux_ref_fonte


#############################################################################################################
######################################### Função principal ###############################################
#############################################################################################################

Funcao ordenar_blocos(n_linhas_arquivo, P, M)

    Conjunto_Arquivos_Fonte = arquivos de P ate 2P-1
    Conjunto_Arquivos_Destino = arquivos de 0 ate P-1

    tamanho_bloco_ordenado_atual = M // os primeiros arquivos ordenados começam com tamanho M (mudam a cada iteração)

    while(tamanho_bloco_ordenado_atual < n_linhas_arquivo) // Enquanto todos os dados não estiverem em um único bloco ordenado
        Limpar_Arquivos_Destino // so p evitar dar problema
        indice_arquivo_destino_atual = 0 // Inicia a distribuição no primeiro arquivo de destino 9sera alterado pra cada bloco de merges feitos

        num_blocos_ordenados_totais_nesta_passagem = Calcular_Num_Blocos_Totais_Nesta_Passagem(n_linhas_arquivo, tamanho_bloco_ordenado_atual)

        // Itera sobre os grupos de P blocos ordenados para realizar o merge (faz merge dos primeiros/segundos/terceiros... grupos em cada arquivo)
        //o i varia de zero ate o indice do ultimo grupo, o resultado deveser o num max de elementos em um arquivo
        for (int i=0; i<CEIL(num_blocos_ordenados_totais_nesta_passagem / (double)P); i++)
            abre arquivos de origem para leitura 

            Se Contador_Blocos_Ordenados_Abertos == 0:
                se nao tiver mais blocos pra ordenar, quebra esse loop (ajeitar)
            
            abre arquivo de escrita para escrever
            
            Vetor_Proximas_Linhas = Inicializar_Vetor_Proximas_Linhas() (vetor com os menores elementos)
            
            Realizar_Merge_De_P_Vias() realiza um merge 
            
            fecha os canais de leitura e escrita
            
            atualiza o indice_arquivo_destino_atual (aumenta de 1 em 1 e se chegar no limite volta pro primeiro - funcao q faz isso)
        
        Trocar_Conjuntos_Arquivos // Troca os papéis para a próxima passagem
        
        tamanho_bloco_ordenado_atual *= P // O tamanho dos blocos ordenados aumenta por um fator de P
