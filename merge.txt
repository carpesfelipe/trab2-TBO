//n_linhas_arquivo é o numero total de linhas do arquivo original

Funcao ordenar_blocos(n_linhas_arquivo, arquivos, P, M)

    arquivos_fonte = P (marca o inicio dos arquivos fontes) arquivos de P ate 2P-1
    arquvos_destino = 0 (marca o inicio dos arquivos destino) arquivos de 0 ate P-1

    tam_grupos = M (muda a cada iteracao - começa com M)

    while(tam_grupos < n_linhas_arquivo) // ve se todas as linhas estao em um arquivo entao ja acabou ordenacao (se tam_grupos = n total de linhas do arquivo, entao ja juntou todos)
        limpar_arquivos_destino
        indice_arquivo_destino = 0 (se os escritos comecam em p)

        // Calcula o número total de blocos ordenados de 'tamanho_bloco_ordenado_atual' existentes para processar
        num_blocos_ordenados_totais_nesta_passagem = CEIL(n_linhas_arquivo / tamanho_bloco_ordenado_atual)

        // iterando sobre os grupos de P blocos ordenados a serem intercalados em um único passo
        for (int i=0; i<CEIL(num_blocos_ordenados_totais_nesta_passagem / (double)P); i++)
            lista = inicializa lista com os menores elemtos
            Contador_Blocos_Ordenados_Abertos = 0

            menor = lista[0] //inicializa o menor elemento

            // identifica e abre (ate) os P's blocos ordenados (aqui abre os canais p um Merge dos P blocos ordenados)
            for(int j=0; j< P; j++)
                indice_bloco_ordenado = (i*P) +j //calcula qual o bloco vamos ver (qual o "indice" do bloco dentro de cada arquivo - se estamos olhando pro brimeiro, segundo, terceiro... bloco)

                verifica se bloco existe   
                Se indice_bloco_ordenado_global < num_blocos_ordenados_totais_nesta_passagem: // Verifica se este bloco ordenado existe

                    abre arquivos de leitura necessaios

                    Contador_Blocos_Ordenados_Abertos = Contador_Blocos_Ordenados_Abertos + 1
                se nao
                    quebra o loop (volta p j)
                
            se Contador_Blocos_Ordenados_Abertos == 0
                quebra loop (volta p i)
            
            canal_escrita = Abrir_Canal_Escrita_Para_Arquivo(Conjunto_Arquivos_Destino, indice_arquivo_destino_atual)

            // Vetor que armazenará a próxima linha de cada um dos canais de entrada
            Vetor_Proximas_Linhas = Array de tamanho P // Inicializa com capacidade P


            // Inicializa o vetor com a primeira linha de cada canal de leitura
            Para cada canal em Lista_Canais_Leitura:
                Se canal.TemMaisLinhas():
                    linha = canal.LerProximaLinha()
                    Vetor_Proximas_Linhas[canal.ID] = (linha, canal.ID) // Assume que canal.ID é um índice válido para o vetor
                Senão:
                    Vetor_Proximas_Linhas[canal.ID] = VAZIO // Marca a posição como vazia


            // Loop principal da intercalação: continua enquanto houver linhas válidas para intercalar
            Enquanto EXISTE_LINHA_VALIDA_NO_VETOR(Vetor_Proximas_Linhas):
                // Encontrar a menor linha no vetor (busca linear, como planejado para P pequeno)
                menor_linha = NULO // Sentinela para a menor linha encontrada
                ID_do_menor_canal = -1

                Para cada posicao 'idx' de 0 até Vetor_Proximas_Linhas.Tamanho - 1:
                    Se Vetor_Proximas_Linhas[idx] NÃO É VAZIO:
                        (linha_candidata, ID_candidato) = Vetor_Proximas_Linhas[idx]
                        Se menor_linha É NULO OU Comparar(linha_candidata, menor_linha) < 0:
                            menor_linha = linha_candidata
                            ID_do_menor_canal = ID_candidato
                
                Se menor_linha É NULO: // Se o vetor está todo VAZIO, não há mais linhas para intercalar
                    Quebrar Loop // Sai do Enquanto EXISTE_LINHA_VALIDA_NO_VETOR

                Escrever(menor_linha, canal_escrita) // Escreve a menor linha no arquivo de saída

                // Lê a próxima linha DO MESMO BLOCO ORDENADO de onde a menor linha veio
                canal_origem = Encontrar_Canal_Por_ID(Lista_Canais_Leitura, ID_do_menor_canal)
                Se canal_origem.TemMaisLinhas():
                    nova_linha = canal_origem.LerProximaLinha()
                    Vetor_Proximas_Linhas[ID_do_menor_canal] = (nova_linha, ID_do_menor_canal)
                Senão:
                    Vetor_Proximas_Linhas[ID_do_menor_canal] = VAZIO // Marca como exaurido

            //aqui acaba um ciclo de merge (organizando e preparando pro prox)
            Para cada canal em Lista_Canais_Leitura:
                canal.Fechar() // Fecha os canais de leitura dos blocos ordenados que foram consumidos
            canal_escrita.Fechar() // Fecha o canal de escrita do novo bloco ordenado gerado

            indice_arquivo_destino_atual = (indice_arquivo_destino_atual + 1) % P // Isso garante a distribuição cíclica entre 0 e P-1

    Trocar conjuntos fonte e destino 

    tamanho_bloco_ordenado_atual *= P;


Funcao trocar_conjuntos_fonte_e_destino(arquivos_fonte, arquvos_destino)
    int aux = arquivos_fonte
    arquivos_fonte = arquvos_destino
    arquvos_destino = aux
